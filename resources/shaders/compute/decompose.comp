layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba32f) readonly uniform highp image2D stateIn;
layout(binding = 1, r32f) readonly uniform highp image2D terrain;
layout(binding = 2, rgba32f) writeonly uniform highp image2D bulkFlow;
layout(binding = 3, rg32f) writeonly uniform highp image2D surfaceHeight;
layout(binding = 4, rg32f) writeonly uniform highp image2D surfaceQx;
layout(binding = 5, rg32f) writeonly uniform highp image2D surfaceQy;
layout(binding = 6, rgba32f) readonly uniform highp image2D tempIn;
layout(binding = 7, rgba32f) writeonly uniform highp image2D tempOut;

uniform float dx;
uniform float dt;
uniform int stage;
uniform float decompositionD;
uniform float dryEps;

// It would be better to split it into 3 shader for optimisation but this was easier

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 gridSize = imageSize(stateIn);

    if (pos.x >= gridSize.x - 1 || pos.y >= gridSize.y - 1 || pos.x <= 0 || pos.y <= 0) {
        float terrainc = imageLoad(terrain, pos).r;
        if (stage == 0 || stage == 1) {
            imageStore(tempOut, pos, vec4(terrainc, 0.0, 0.0, 0.0));
        } else if (stage == 2) {
            imageStore(bulkFlow, pos, vec4(0.0, 0.0, 0.0, 1.0));
            imageStore(surfaceHeight, pos, vec4(0.0, 0.0, 0.0, 1.0));
            imageStore(surfaceQx, pos, vec4(0.0, 0.0, 0.0, 1.0));
            imageStore(surfaceQy, pos, vec4(0.0, 0.0, 0.0, 1.0));
        }
        return;
    }

    float terrainc = imageLoad(terrain, pos).r;

    if (stage == 0) { // Initialisation
        vec4 statec = imageLoad(stateIn, pos);
        
        float h = statec.x;
        float qx = statec.y;
        float qy = statec.z;
        
        if (h < dryEps) {
            imageStore(tempOut, pos, vec4(terrainc, 0.0, 0.0, 0.0));
            return;
        }
        
        vec4 statel = imageLoad(stateIn, pos + ivec2(-1, 0));
        vec4 stater = imageLoad(stateIn, pos + ivec2(1, 0));
        vec4 statet = imageLoad(stateIn, pos + ivec2(0, 1));
        vec4 stateb = imageLoad(stateIn, pos + ivec2(0, -1));

        float terrainl = imageLoad(terrain, pos + ivec2(-1, 0)).r;
        float terrainr = imageLoad(terrain, pos + ivec2(1, 0)).r;
        float terraint = imageLoad(terrain, pos + ivec2(0, 1)).r;
        float terrainb = imageLoad(terrain, pos + ivec2(0, -1)).r;

        float H = h + terrainc;

        vec2 gradH = vec2(
            (stater.x + terrainr - statel.x - terrainl) / (2.0 * dx),
            (statet.x + terraint - stateb.x - terrainb) / (2.0 * dx)
        );
        float gradMag = length(gradH);

        float d = decompositionD;
        float alpha = (h * h) / 128.0;
        alpha *= exp(-d * gradMag * gradMag);

        imageStore(tempOut, pos, vec4(H, qx, qy, alpha));
    }
    else if (stage == 1) { //Diffusion
        vec4 temp_c = imageLoad(tempIn, pos);
        
        ivec2 posL = ivec2(max(pos.x - 1, 1), pos.y);
        ivec2 posR = ivec2(min(pos.x + 1, gridSize.x - 2), pos.y);
        ivec2 posT = ivec2(pos.x, min(pos.y + 1, gridSize.y - 2));
        ivec2 posB = ivec2(pos.x, max(pos.y - 1, 1));
        
        vec4 temp_l = imageLoad(tempIn, posL);
        vec4 temp_r = imageLoad(tempIn, posR);
        vec4 temp_t = imageLoad(tempIn, posT);
        vec4 temp_b = imageLoad(tempIn, posB);

        float alpha_c = temp_c.w;
        float alpha_l = temp_l.w;
        float alpha_r = temp_r.w;
        float alpha_t = temp_t.w;
        float alpha_b = temp_b.w;
        
        float alpha_face_l = (alpha_c + alpha_l) * 0.5;
        float alpha_face_r = (alpha_c + alpha_r) * 0.5;
        float alpha_face_t = (alpha_c + alpha_t) * 0.5;
        float alpha_face_b = (alpha_c + alpha_b) * 0.5;
        
        float max_alpha = max(max(alpha_face_l, alpha_face_r), max(alpha_face_t, alpha_face_b));
        float diffusion_dt = min(0.25 * dx * dx / max(max_alpha, 1e-6), 0.25);

        float diff_H = (alpha_face_r * (temp_r.x - temp_c.x) - alpha_face_l * (temp_c.x - temp_l.x) +
                        alpha_face_t * (temp_t.x - temp_c.x) - alpha_face_b * (temp_c.x - temp_b.x)) / (dx * dx);
        float diff_qx = (alpha_face_r * (temp_r.y - temp_c.y) - alpha_face_l * (temp_c.y - temp_l.y) +
                         alpha_face_t * (temp_t.y - temp_c.y) - alpha_face_b * (temp_c.y - temp_b.y)) / (dx * dx);
        float diff_qy = (alpha_face_r * (temp_r.z - temp_c.z) - alpha_face_l * (temp_c.z - temp_l.z) +
                         alpha_face_t * (temp_t.z - temp_c.z) - alpha_face_b * (temp_c.z - temp_b.z)) / (dx * dx);

        float H_new = temp_c.x + diff_H * diffusion_dt;
        float qx_new = temp_c.y + diff_qx * diffusion_dt;
        float qy_new = temp_c.z + diff_qy * diffusion_dt;

        imageStore(tempOut, pos, vec4(H_new, qx_new, qy_new, alpha_c));
    }
    else if (stage == 2) { // Final
        vec4 statec = imageLoad(stateIn, pos);
        vec4 filtered = imageLoad(tempIn, pos);

        float h = statec.x;
        float qx = statec.y;
        float qy = statec.z;

        if (h < dryEps) {
            imageStore(bulkFlow, pos, vec4(0.0, 0.0, 0.0, 1.0));
            imageStore(surfaceHeight, pos, vec4(0.0, 0.0, 0.0, 1.0));
            imageStore(surfaceQx, pos, vec4(0.0, 0.0, 0.0, 1.0));
            imageStore(surfaceQy, pos, vec4(0.0, 0.0, 0.0, 1.0));
            return;
        }

        float bulk_h = filtered.x - terrainc;
        bulk_h = clamp(bulk_h, 0.0, h);
        float surface_h = h - bulk_h;

        float bulk_qx = filtered.y;
        float bulk_qy = filtered.z;
        float surface_qx = qx - bulk_qx;
        float surface_qy = qy - bulk_qy;

        imageStore(bulkFlow, pos, vec4(bulk_h, bulk_qx, bulk_qy, 1.0));
        imageStore(surfaceHeight, pos, vec4(surface_h, 0.0, 0.0, 1.0));
        imageStore(surfaceQx, pos, vec4(surface_qx, 0.0, 0.0, 1.0));
        imageStore(surfaceQy, pos, vec4(surface_qy, 0.0, 0.0, 1.0));
    }
}