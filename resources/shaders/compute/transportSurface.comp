layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba32f) writeonly uniform highp image2D stateOut;
layout(binding = 1, rgba32f) readonly uniform highp image2D bulkFlow;
layout(binding = 2, rg32f) uniform highp image2D surfaceHeight;
layout(binding = 3, rg32f) uniform highp image2D surfaceQx;
layout(binding = 4, rg32f) uniform highp image2D surfaceQy;

void main() {

    float eps = 1e-3;

    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 gridSize = imageSize(stateOut);

    if (pos.x >= uint(gridSize.x) || pos.y >= uint(gridSize.y)) {
        return;
    }

    // 

    vec4 statec = imageLoad(bulkFlow, pos);
    vec4 statel = imageLoad(bulkFlow, pos + ivec2(-1, 0));
    vec4 stater = imageLoad(bulkFlow, pos + ivec2(1, 0));
    vec4 statet = imageLoad(bulkFlow, pos + ivec2(0, 1));
    vec4 stateb = imageLoad(bulkFlow, pos + ivec2(0, -1));

    float surfhc = imageLoad(surfaceHeight, pos).r;
    float surfhl = imageLoad(surfaceHeight, pos + ivec2(-1, 0)).r;
    float surfhr = imageLoad(surfaceHeight, pos + ivec2(1, 0)).r;

    float surfqxc = imageLoad(surfaceQx, pos).r;
    float surfqxl = imageLoad(surfaceQx, pos + ivec2(-1, 0)).r;
    float surfqxr = imageLoad(surfaceQx, pos + ivec2(1, 0)).r;

    float surfqyc = imageLoad(surfaceQy, pos).r;
    float surfqyl = imageLoad(surfaceQy, pos + ivec2(-1, 0)).r;
    float surfqyr = imageLoad(surfaceQy, pos + ivec2(1, 0)).r;

    float ux = surfqxc / max(surfhc, eps);
    float uy = surfqyc / max(surfhc, eps);

    float uxl = surfqxl / max(surfhl, eps);
    float uxr = surfqxr / max(surfhr, eps);

    float uyl = surfqyl / max(surfhl, eps);
    float uyr = surfqyr / max(surfhr, eps);

    //float laplacian_h = (stater.x - statec.x) /dx;

}