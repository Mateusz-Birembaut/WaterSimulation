layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, rgba32f) uniform image2D uStateTexture;

struct Disturbance {
    ivec2 position;  // pixel position (px, py)
    float strength;  // momentum magnitude
    float _padding;  // align to 16 bytes
};

layout(std430, binding = 1) readonly buffer DisturbanceBuffer {
    Disturbance disturbances[];
};

uniform int uDisturbanceCount;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    
    if (int(idx) >= uDisturbanceCount)
        return;
    
    Disturbance d = disturbances[idx];
    ivec2 pos = d.position;
    float strength = d.strength;
    
    vec4 state = imageLoad(uStateTexture, pos);
    
    // Apply Gaussian smoothing to avoid high-frequency spikes that break Airy waves
    ivec2 size = imageSize(uStateTexture);
    int radius = 2;

    float totalWeight = 0.0;
    for(int dy = -radius; dy <= radius; ++dy) {
        for(int dx = -radius; dx <= radius; ++dx) {
            float dist2 = float(dx*dx + dy*dy);
            totalWeight += exp(-dist2 / 2.0);
        }
    }

    // Safety to avoid division by zero
    if (totalWeight <= 0.0) totalWeight = 1.0;

    const float maxDelta = strength * 1.0; // cap per disturbance to avoid large spikes

    for(int dy = -radius; dy <= radius; ++dy) {
        for(int dx = -radius; dx <= radius; ++dx) {
            ivec2 p = pos + ivec2(dx, dy);
            
            if(p.x < 0 || p.y < 0 || p.x >= size.x || p.y >= size.y) 
                continue;
                
            float dist2 = float(dx*dx + dy*dy);
            float weight = exp(-dist2 / 2.0) / totalWeight; 
            float delta = strength * weight;
            delta = clamp(delta, -maxDelta, maxDelta);
            
            vec4 s = imageLoad(uStateTexture, p);
            s.x += delta;
            imageStore(uStateTexture, p, s);
        }
    }
}
