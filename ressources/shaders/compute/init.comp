layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba32f) readonly uniform highp image2D stateIn; // r = h, g = qx, b = qy, a = not used
layout(binding = 1, rgba32f) writeonly uniform highp image2D stateOut;
layout(binding = 2, r32f) readonly uniform highp image2D terrain;

uniform float dx;
uniform float dt;
uniform float gravity;
uniform float dryEps;
uniform float friction_coef;

uniform int init_type;

void main() {
    uvec3 globalID = gl_GlobalInvocationID;
    ivec2 gridSize = imageSize(stateOut);
    
    if (globalID.x >= (uint(gridSize.x) - 1u) || globalID.y >= (uint(gridSize.y) - 1u)) {
        return;
    }
    
    if(init_type == 0){ //init flat with bump
        int centerX = gridSize.x / 2;
        int centerY = gridSize.y / 2;
        float bumpHeight = 1.0;
        float baseLevel = 2.0;

        float distance = length(vec2(globalID.xy) - vec2(centerX, centerY));
        float radius = 16.0;
        float terrainHeight = imageLoad(terrain, ivec2(globalID.xy)).r;
        float totalHeight = baseLevel - terrainHeight;

        vec4 state = vec4(0.0);

        if (totalHeight > dryEps) {
            state.r = totalHeight;
            if (distance < radius) {
                state.r += bumpHeight * (1.0 - distance / radius);
            }
        }

        state.g = 0.0; // qx
        state.b = 0.0; // qy
        state.a = 1.0;

        imageStore(stateOut, ivec2(globalID.xy), state);

    }else if (init_type == 1){//init dam break

        float waterLevel = 3.0;
        int damPosition = gridSize.y / 6;
        
        float terrainHeight = imageLoad(terrain, ivec2(globalID.xy)).r;
        vec4 state = vec4(0.0);
        
        if (globalID.y < uint(damPosition)) {
            float depth = waterLevel - terrainHeight;
            state.r = max(0.0, depth);
        } else {
            state.r = 0.0;
        }
        
        state.g = 0.0; //qx
        state.b = 0.0; //qy
        state.a = 1.0;
        
        imageStore(stateOut, ivec2(globalID.xy), state);

    }

    
}